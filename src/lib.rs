/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__max_align_ll) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__max_align_ll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__max_align_ld) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__max_align_ld)
        )
    );
}
pub const zsv_status_zsv_status_ok: zsv_status = 0;
pub const zsv_status_zsv_status_cancelled: zsv_status = 1;
pub const zsv_status_zsv_status_no_more_input: zsv_status = 2;
pub const zsv_status_zsv_status_invalid_option: zsv_status = 3;
pub const zsv_status_zsv_status_memory: zsv_status = 4;
pub const zsv_status_zsv_status_error: zsv_status = 5;
pub const zsv_status_zsv_status_row: zsv_status = 6;
pub const zsv_status_zsv_status_done: zsv_status = 100;
pub const zsv_status_zsv_status_max_rows_read: zsv_status = 999;
pub type zsv_status = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zsv_scanner {
    _unused: [u8; 0],
}
pub type zsv_parser = *mut zsv_scanner;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zsv_cell {
    pub str_: *mut ::std::os::raw::c_uchar,
    pub len: usize,
    pub quoted: ::std::os::raw::c_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[test]
fn bindgen_test_layout_zsv_cell() {
    const UNINIT: ::std::mem::MaybeUninit<zsv_cell> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<zsv_cell>(),
        24usize,
        concat!("Size of: ", stringify!(zsv_cell))
    );
    assert_eq!(
        ::std::mem::align_of::<zsv_cell>(),
        8usize,
        concat!("Alignment of ", stringify!(zsv_cell))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_cell),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_cell),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quoted) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_cell),
            "::",
            stringify!(quoted)
        )
    );
}
impl zsv_cell {
    #[inline]
    pub fn overwritten(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_overwritten(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        overwritten: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let overwritten: u8 = unsafe { ::std::mem::transmute(overwritten) };
            overwritten as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type zsv_generic_write = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    ) -> usize,
>;
pub type zsv_generic_read = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        n: usize,
        size: usize,
        arg2: *mut ::std::os::raw::c_void,
    ) -> usize,
>;
pub type zsv_progress_callback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        cumulative_row_count: usize,
    ) -> ::std::os::raw::c_int,
>;
pub type zsv_completed_callback = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, code: ::std::os::raw::c_int),
>;
pub const zsv_overwrite_type_zsv_overwrite_type_unknown: zsv_overwrite_type = 0;
pub const zsv_overwrite_type_zsv_overwrite_type_none: zsv_overwrite_type = 1;
pub const zsv_overwrite_type_zsv_overwrite_type_csv: zsv_overwrite_type = 2;
pub type zsv_overwrite_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zsv_opt_overwrite {
    pub type_: zsv_overwrite_type,
    pub ctx: *mut ::std::os::raw::c_void,
    pub close_ctx: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_zsv_opt_overwrite() {
    const UNINIT: ::std::mem::MaybeUninit<zsv_opt_overwrite> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<zsv_opt_overwrite>(),
        24usize,
        concat!("Size of: ", stringify!(zsv_opt_overwrite))
    );
    assert_eq!(
        ::std::mem::align_of::<zsv_opt_overwrite>(),
        8usize,
        concat!("Alignment of ", stringify!(zsv_opt_overwrite))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opt_overwrite),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opt_overwrite),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_ctx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opt_overwrite),
            "::",
            stringify!(close_ctx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zsv_opts {
    pub row_handler: ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>,
    pub cell_handler: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::std::os::raw::c_void,
            utf8_value: *mut ::std::os::raw::c_uchar,
            len: usize,
        ),
    >,
    pub overflow_row_handler:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>,
    pub ctx: *mut ::std::os::raw::c_void,
    pub read: zsv_generic_read,
    pub stream: *mut ::std::os::raw::c_void,
    pub buff: *mut ::std::os::raw::c_uchar,
    pub buffsize: usize,
    pub max_columns: ::std::os::raw::c_uint,
    pub max_row_size: ::std::os::raw::c_uint,
    pub delimiter: ::std::os::raw::c_char,
    pub no_quotes: ::std::os::raw::c_char,
    pub verbose: ::std::os::raw::c_char,
    pub insert_header_row: *const ::std::os::raw::c_char,
    pub header_span: ::std::os::raw::c_uint,
    pub rows_to_ignore: ::std::os::raw::c_uint,
    pub keep_empty_header_rows: ::std::os::raw::c_uchar,
    pub malformed_utf8_replace: ::std::os::raw::c_char,
    pub progress: zsv_opts__bindgen_ty_1,
    pub completed: zsv_opts__bindgen_ty_2,
    pub max_rows: usize,
    pub overwrite: zsv_opt_overwrite,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zsv_opts__bindgen_ty_1 {
    pub rows_interval: usize,
    pub seconds_interval: ::std::os::raw::c_uint,
    pub callback: zsv_progress_callback,
    pub ctx: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_zsv_opts__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<zsv_opts__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<zsv_opts__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(zsv_opts__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<zsv_opts__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(zsv_opts__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rows_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts__bindgen_ty_1),
            "::",
            stringify!(rows_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seconds_interval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts__bindgen_ty_1),
            "::",
            stringify!(seconds_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts__bindgen_ty_1),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts__bindgen_ty_1),
            "::",
            stringify!(ctx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zsv_opts__bindgen_ty_2 {
    pub callback: zsv_completed_callback,
    pub ctx: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_zsv_opts__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<zsv_opts__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<zsv_opts__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(zsv_opts__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<zsv_opts__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(zsv_opts__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts__bindgen_ty_2),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts__bindgen_ty_2),
            "::",
            stringify!(ctx)
        )
    );
}
#[test]
fn bindgen_test_layout_zsv_opts() {
    const UNINIT: ::std::mem::MaybeUninit<zsv_opts> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<zsv_opts>(),
        184usize,
        concat!("Size of: ", stringify!(zsv_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<zsv_opts>(),
        8usize,
        concat!("Alignment of ", stringify!(zsv_opts))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).row_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(row_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cell_handler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(cell_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_row_handler) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(overflow_row_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buff) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(buff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffsize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(buffsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_columns) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(max_columns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_row_size) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(max_row_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delimiter) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(delimiter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_quotes) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(no_quotes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verbose) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(verbose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).insert_header_row) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(insert_header_row)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_span) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(header_span)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rows_to_ignore) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(rows_to_ignore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep_empty_header_rows) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(keep_empty_header_rows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).malformed_utf8_replace) as usize - ptr as usize },
        97usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(malformed_utf8_replace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progress) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(progress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).completed) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(completed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_rows) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(max_rows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overwrite) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(zsv_opts),
            "::",
            stringify!(overwrite)
        )
    );
}
extern "C" {
    pub fn zsv_new(opts: *mut zsv_opts) -> zsv_parser;
}
extern "C" {
    pub fn zsv_parse_more(parser: zsv_parser) -> zsv_status;
}
extern "C" {
    pub fn zsv_finish(arg1: zsv_parser) -> zsv_status;
}
extern "C" {
    pub fn zsv_delete(arg1: zsv_parser) -> zsv_status;
}
extern "C" {
    pub fn zsv_cell_count(parser: zsv_parser) -> usize;
}
extern "C" {
    pub fn zsv_get_cell(parser: zsv_parser, index: usize) -> zsv_cell;
}
extern "C" {
    pub fn zsv_get_cell_len(parser: zsv_parser, ix: usize) -> usize;
}
extern "C" {
    pub fn zsv_get_cell_str(parser: zsv_parser, ix: usize) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn zsv_lib_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn zsv_set_row_handler(
        arg1: zsv_parser,
        row_handler: ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn zsv_row_is_blank(parser: zsv_parser) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn zsv_set_context(parser: zsv_parser, ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn zsv_set_read(
        parser: zsv_parser,
        read_func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                n: usize,
                size: usize,
                arg2: *mut ::std::os::raw::c_void,
            ) -> usize,
        >,
    );
}
extern "C" {
    pub fn zsv_set_input(arg1: zsv_parser, in_: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn zsv_set_scan_filter(
        parser: zsv_parser,
        filter: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut ::std::os::raw::c_void,
                buff: *mut ::std::os::raw::c_uchar,
                bufflen: usize,
            ) -> usize,
        >,
        ctx: *mut ::std::os::raw::c_void,
    ) -> zsv_status;
}
extern "C" {
    pub fn zsv_set_fixed_offsets(
        parser: zsv_parser,
        count: usize,
        offsets: *mut usize,
    ) -> zsv_status;
}
extern "C" {
    pub fn zsv_parse_bytes(
        parser: zsv_parser,
        buff: *const ::std::os::raw::c_uchar,
        len: usize,
    ) -> zsv_status;
}
extern "C" {
    pub fn zsv_parse_status_desc(status: zsv_status) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn zsv_abort(arg1: zsv_parser);
}
extern "C" {
    pub fn zsv_scanned_length(arg1: zsv_parser) -> usize;
}
extern "C" {
    pub fn zsv_cum_scanned_length(parser: zsv_parser) -> usize;
}
extern "C" {
    pub fn zsv_quoted(parser: zsv_parser) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn zsv_opts_new(
        row_handler: ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>,
        cell_handler: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut ::std::os::raw::c_void,
                utf8_value: *mut ::std::os::raw::c_uchar,
                len: usize,
            ),
        >,
        ctx: *mut ::std::os::raw::c_void,
        read: zsv_generic_read,
        stream: *mut ::std::os::raw::c_void,
        buff: *mut ::std::os::raw::c_uchar,
        buffsize: usize,
        max_columns: ::std::os::raw::c_uint,
        max_row_size: ::std::os::raw::c_uint,
        delimiter: ::std::os::raw::c_char,
        no_quotes: ::std::os::raw::c_char,
        max_rows: usize,
    ) -> *mut zsv_opts;
}
extern "C" {
    pub fn zsv_opts_delete(arg1: *mut zsv_opts);
}
extern "C" {
    pub fn zsv_next_row(parser: zsv_parser) -> zsv_status;
}
extern "C" {
    pub fn zsv_strencode(
        s: *mut ::std::os::raw::c_uchar,
        n: usize,
        replace: ::std::os::raw::c_uchar,
        malformed_handler: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                s: *const ::std::os::raw::c_uchar,
                n: usize,
                offset: usize,
            ) -> ::std::os::raw::c_int,
        >,
        handler_ctx: *mut ::std::os::raw::c_void,
    ) -> usize;
}
